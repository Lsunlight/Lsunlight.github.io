{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"第一篇博客","date":"2022-11-17T10:37:18.182Z","updated":"2022-11-19T12:49:24.292Z","comments":true,"path":"2022/11/17/第一篇博客/","link":"","permalink":"http://example.com/2022/11/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"title: Node 笔记date: 2022-11-17 18:37:18tags: 1","categories":[],"tags":[]},{"title":"","slug":"JS构造函数原型","date":"2022-10-31T11:40:50.300Z","updated":"2022-11-20T00:58:23.446Z","comments":true,"path":"2022/10/31/JS构造函数原型/","link":"","permalink":"http://example.com/2022/10/31/JS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"JS高级一 构造函数存在的问题12345678910111213141516171819构造函数存在浪费内存的问题 构造函数存在的问题 function Star(name, age) &#123; this.name = name this.age = age this.sing = function () &#123; console.log(&#x27;唱歌&#x27;) //方法 &#125; &#125; const kk = new Star(&#x27;坤坤&#x27;, 18) const jl = new Star(&#x27;杰伦&#x27;, 20) // console.log(kk, jl) console.log(kk.sing === jl.sing) // false 表示内存中sing的地址不相等 kk.sing() 每创建一个对象，都会在堆内存空间新开辟一个空间来存储方法 ps. 我们常说的指针/指向： 表示的就是内存中的地址(房间号/门牌号),这个地址指向了内存中数据的真实位置 二 映入原型对象12345678910111213141516171819202122function Star(name, age)&#123; // 1. 公共的属性写到构造函数里面 this.name = name this.age = age &#125; // 2. 公共的方法写到原型对象上 节约了内存 Star.prototype.sing = function()&#123; console.log(&#x27;唱歌&#x27;) &#125; const kk = new Star(&#x27;坤坤&#x27;, 18) const jl = new Star(&#x27;杰伦&#x27;, 20) console.log(jl, kk) kk.sing() jl.sing() //sing是公共的方法 在内存中里面的地址是相同的 console.log(kk.sing === jl.sing) //true //以后：一般情况下 //1. 公共的属性写到构造函数里面 //2.公共的方法放到原型对象上 三 原型prototype123456789101112131415161718192021222324252627282930313233343536原型：字面量意思 原来的模型 原始祖先 原始的模型JS原型：原型就是一个对象也叫原型对象1 所有的函数，都有一个prototype属性，属性值也是一个普通的对象1.1 所有的函数，都有一个prototype属性(显示原型)，这个属性是一个指针，指向原型对象(原型) function Person() &#123; &#125; console.dir(Person)2 原型上默认有一个叫做constructor的属性,指向这个构造函数本身 console.log(Person.prototype.constructor === Person)3 我们可以往这个原型对象中添加属性和方法 Person.prototype.sing = function () &#123; console.log(&#x27;哈哈哈&#x27;) &#125; Person.prototype.demo = &#x27;我是原型上的一个属性&#x27; console.dir(Person)================================================== function Star(name, age) &#123; // 1. 公共的属性写到构造函数里面 this.name = name this.age = age &#125; // 2. 公共的方法写到原型对象上 节约了内存 Star.prototype.sing = function () &#123; console.log(&#x27;唱歌&#x27;) &#125; Star.prototype.cheer = &#x27;Day Day up&#x27; // ==&gt; 所有通过构造函数创建的对象，都共享原型上的属性和方法！ const ldh = new Star(&#x27;刘德华&#x27;, 20) const zxy = new Star(&#x27;张学友&#x27;, 21) ldh.sing() zxy.sing() console.log(ldh.cheer) console.log(zxy.cheer) 四 构造函数和原型方法中的this1234567891011121314151617let that = null // 全局变量 function Star(name, age) &#123; this.name = name this.age = age console.log(this) // ? 执行完构造函数this就被释放了 that = this // that把this的指向/状态 保存起来了 &#125; //这里我们声明了一个全局变量that在调用new的时候保存this的状态 // 调用结束后 如果that还是指向的构造函数创建的实例，说明我们的结论没问题 Star.prototype.sing = function () &#123; console.log(&#x27;唱歌&#x27;) &#125; //1.构造函数里面的this指向的是实例对象 const ll = new Star(&#x27;霖霖&#x27;,18) console.log(that) ll.sing() // 2. 原型方法中的this指向的还是实例对象 五 constructor属性12345678910111213141516171819function Star(name, age) &#123; this.name = name this.age = age &#125; const ll = new Star(&#x27;磊磊&#x27;, 28) // constructor console.dir(Star) // ===&gt; 首先 constructor在原型(对象)上 // 1. 每个原型(对象)上默认都有一个constructor属性，指回构造函数本身 // 表示我，我这个原型 是哪个构造函数的原型 其实就是相当于是一个标识(标记) Star.prototype.constructor === Star // 理解记忆！！！ // 2. 所有对象的隐式原型指向构造函数的显示原型 console.log(ll.__proto__ === Star.prototype) // true 背下来 // ll.__proto__ ==&gt; 指向的也是原型对象 console.log(ll.__proto__.constructor === Star) // true 理解记忆！！！ 六 constructor的应用1234567891011121314151617181920212223242526272829303132333435363738// 每个原型对象中都有一个constructor属性，指回构造函数本身 function Star(name, age) &#123; this.name = name this.age = age &#125; // Star.prototype.sing = function()&#123; // console.log(&#x27;唱歌&#x27;) // &#125; // Star.prototype.dance = function()&#123; // console.log(&#x27;dance&#x27;) // &#125; // Star.prototype.rap = function()&#123; // console.log(&#x27;rap&#x27;) // &#125; // 1. 上述的方式给原型添加公共方法，不会修改原型。 // 我们如果直接给Star.prototype赋值一个对象，这个时候，原型上的默认属性constructor就会丢失掉。 // 我们可以手动给这个对象添加constructor属性，指回这个构造函数 // 2. 这种以对象赋值的方式，会覆盖掉原型。 需要我们手动添加一个constructor属性 Star.prototype = &#123; constructor: Star, // 指回构造函数 sing: function () &#123; console.log(&#x27;唱歌&#x27;) &#125;, dance: function () &#123; console.log(&#x27;dance&#x27;) &#125;, rap: function () &#123; console.log(&#x27;rap&#x27;) &#125; &#125; const ldh = new Star(&#x27;刘德华&#x27;, 18) ldh.__proto__ === Star.prototype // ==&gt; 原型对象 console.log(ldh) ldh.sing() ldh.dance() 七__proto__ 隐式原型123456789101112131415161718192021222324252627 function Star(name, age) &#123; this.name = name this.age = age &#125; Star.prototype.sing = function () &#123; console.log(&#x27;sing&#x27;) &#125; const ldh = new Star(&#x27;刘德华&#x27;, 20)1 所有的对象都有一个__proto__属性(隐式原型)属性值也是一个对象(其实就是指向的原型对象) __proto__属性隐式原型// 实例通过__proto__访问(链接)到了它的原型对象// __proto__相当于一个桥梁 链接 实例就是通过__proto__访问到原型对象2 对象的隐式属性原型指向构造函数的显示原型 ldh.__proto__ === Star.prototype //true /*================ eg ======================*/ function Animal() &#123; this.color = &#x27;orange&#x27; &#125; const cat = new Animal() console.log(cat) console.log(cat.__proto__ === Animal.prototype) console.log(Animal.prototype.constructor === Animal) console.log(cat.__proto__.constructor === Animal)1 &#x27;实例对象.__proto__ === 构造函数.prototype&#x27; ==&gt; 原型2 &#x27;__proto__ 表示了实例和原型之间的一个关系，相当于就是一个桥梁，实例通过它访问原型&#x27; 八 构造函数-实例-原型的关系123456四条线：1 构造函数.prototype ===&gt; 原型对象2 原型对象.constructor ===&gt; 构造函数3 实例对象.__proto__ ===&gt; 原型对象4 构造函数 new 创建出 实例对象 高程四 第八章 P250 : 实例与构造函数原型之间有直接的联系（__proto__），但实例与构造函数之间没有直接联系 九 原型链12345678910111213141516171819202122232425262728293031323334353637 function Person(name) &#123; this.name = name &#125; const person = new Person() // 原型链： ===&gt; 规则2 所有的对象都有一个__proto__,属性值也是一个对象1 Person.prototype也是一个对象,所以他也有__proto__属性，属性值也是对象 console.log(Person.prototype.__proto__) // ===&gt; __proto__访问到原型 //Person.prototype.__proto__ ===&gt; &#123;&#125;==&gt; 原型上默认有一个constructor属性，指回的构造函数(我们通过这个知道了Person.prototype的构造函数是Object)===&gt; 规则4 所有对象的隐式原型指向它的构造函数的显示原型 // Person.prototype Person.prototype.__proto__ === Object.prototype // person.__proto__ === Person.prototype// Person.prototype 这个原型对象 是 Object这个构造函数创建的 // 2. Object 它是一个构造函数 // Object.prototype ===&gt; 得到的也是一个原型 // Object.prototype这个原型上默认有一个constructor属性，指向构造函数本身 // Object.prototype ====&gt; 原型 // Person.prototype.__proto__ ==&gt; 原型 console.log(Object.prototype) console.log(Person.prototype.__proto__) // 也就是上面这两个 指向的 都是 Object这个构造函数的原型 console.log(Person.prototype.__proto__ === Object.prototype) // 我们说的原型,可以说是构造函数的原型,也可以说实例的原型,指的都是同一个 // 构造函数 通过 prototype 访问到它的原型 // 实例 通过 __proto__ 访问到它的原型 // 3. Object.prototype // Object.prototype 它也是一个原型对象, 所以 它也有__proto__属性 console.log(Object.prototype) console.log(Object.prototype.__proto__ === null) // 正常的原型链终止到Object.prototype, 也就是Object.prototype.__proto__ === null 原型链总结 重点 要背123456789101112131415161718192021原型链每个对象通过__proto__属性访问到它的原型(对象),原型对象也有它的原型对象(原型也有它的原型)当访问一个对象属性或方法的时候，现在自身寻找如果没有就会沿着__proto__这条链向上查找，直到最顶层的Object为止（null）我们都知道 Object.prototype.__proto__ === null // 数组的原型链 const arr = [1, 2, 3] // 数组也是一个对象 // arr --&gt; Array.prototype --&gt; Object.prototype ---&gt; null console.dir(arr) console.log(Array.prototype) console.log(arr.valueOf()) // 函数的原型链 const fn = function () &#123; &#125; // fn --&gt; Function.prototype --&gt; Object.prototype --&gt; null // 原型链靠的是 __proto__ 链接的 // JS中一切皆对象, ==&gt; Object创建的","categories":[],"tags":[]}],"categories":[],"tags":[]}